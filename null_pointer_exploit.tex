
\chapter{NULL pointer Exploit}
\label{chap:null_pointer_exploit}

	Dentre as várias técnicas de exploits existentes, uma que certamente merece
	destaque, é o NULL pointer exploit.
	Sua disseminação é recente, sendo fruto da crescente dificuldade em aplicar técnicas
	que exploram vulnerabilidades de corrupção de memória.
	

	Um marco para esse tipo de exploit certamente foi o artigo de Mark Dowd \cite{Dowd2008}.
	A forma como ele trouxe à luz uma falha na máquina virtual do ActionScript chamou
	a atenção de diversos especialistas na área. 
	Isso porque, para muitos, o NULL pointer era apenas sinônimo de um \textsl{bug}
	que resultaria, no máximo, em uma negação de serviço.
	Por isso, o raciocínio empregado por ele serviria de base para encontrar muitos outros problemas.

	
	O ano de 2009 chegou a ser considerado o ano do "kernel NULL pointer deference"
	em virtude da grande quantidade de falhas desse gênero encontradas no kernel do Linux.
	Como podemos encontrar em, \cite{Cox2009Top11}, a lista de problemas causados
	por esse tipo de vulnerabilidade foi extensa. Para sistemas Linux Red Hat, por exemplo,
	ainda conforme \cite{Cox2009Top11}, o NULL pointer foi considerado o grande vilão de 2009 com
	6 vulnerabilidades.

	
	Nesse capítulo, nossa intenção é apresentar esse tipo de vulnerabilidade e seu
	correspondente exploit. Assim como identificar os meios de detecção e prevenção. 
	
	
	\section{O que é um NULL pointer}
		O primeiro ponto a ser abordado é o NULL pointer.
		Na linguagem de programação C, podemos considerar um ponteiro como um valor inteiro
		que referencia uma posição de memória. Ou seja, trata-se de um valor que aponta
		para o início de uma determinada região de memória. Quando um ponteiro é deferenciado,
		passamos a acessar o valor presente na posição de memória para o qual ele aponta.
		Ilustrando, segue pequeno trecho de código C.
		\begin{lstlisting}[label=pointer_example,caption=Ponteiro em C]
int val = 10;
int *pointer = &val;
/* pointer has the address of val */

int x = *pointer;
/* *pointer returns 10 */
		\end{lstlisting}
		

		No Linux, o arquivo stddef.h contém a definição de NULL, que por
		convenção, denomina um ponteiro com valor zero.
		Um ponteiro nulo, então, aponta para a posição zero de memória. 
		Como, em regra geral, os sistemas utilizam o esquema de memória virtual,
		na prática, esse endereço zero deve ser considerado tão somente no espaço
		de endereçamento do processo em questão.
		Como normalmente ele não constitui um mapeamento válido, pois os processos não
		iniciam com aquela porção mapeada, os acessos a essa região implicam violação
		às regras do esquema de memória virtual. Erros como esse resultam
		no término da aplicação. Por isso, na maioria dos casos, um acesso a um ponteiro
		nulo é apenas sinônimo de uma DoS (negação de serviço).


				
		Diversas falhas em uma aplicação real podem levar à presença de um ponteiro zerado.
		Falhas ao inicializar uma estrutura de dados pode deixar ponteiros nulos inadvertidamente.
		Outro possível problema pode ocorrer quando o sistema tem sua memória esgotada e, 
		a chamada responsável por alocar mais espaço retorna NULL, mas como essa possibilidade não é considerada
		pelo programador, o ponteiro a receber esse bloco de memória acaba ficando zerado e a aplicação
		segue normalmente.
		
		Vemos, portanto, que um ponteiro nulo é um caso particular no qual a região de memória
		referenciada é aquela que inicia no endereço zero (no contexto de endereçamento do
		processo em questão - considerado o uso de memória virtual). 
		Exceto em casos especiais, essa situação leva a erros na aplicação que resultam em seu término.
		Conforme trataremos a seguir, há casos em que um ponteiro nulo irá possibilitar um ataque.		

	\section{Como funciona a técnica}
		A técnica de exploração desse tipo de vulnerabilidade irá variar conforme o contexto
		em que surge e como é utilizado o ponteiro nulo. 
		Conforme exposto anteriormente, esse método não é tão genérico como as falhas de \textsl{buffer overflow}.
		São ataques mais focados que exigem ajustes muito maiores em função das especifidades da aplicação alvo.
		Como em outros gêneros de exploits, o objetivo desejado é a escrita de dados fornecidos 
		pelo usuário em endereços arbitrários. Pois isso possibilita, por exemplo,
		a cópia de um \textsl{shellcode} para ser executado. Mas isso não é uma regra, há falhas
		de NULL pointer que envolvem ponteiros para funções que possuem um caminho mais simples
		para exploração.

	
		Para fins de simplificação, vamos dividir os tipos de ataques com essa técnica em duas famílias.
		Como podem existir várias formas de exploração de aplicações em que surgem ponteiros nulos,
		para facilitar a compreensão, vamos tomar dois tipos representativos que são capazes de passar
		a ideia fundamental.
		Numa delas, um endereço que define a localização de uma escrita depende de um ponteiro zerado.
		Em outra, esse ponteiro define uma função a ser executada.
		A primeira chamaremos de \textbf{ponteiro nulo de escrita} e a segunda de \textbf{ponteiro nulo de função}.


		\subsection{Ponteiro nulo de escrita}
		\label{subsec:ponteiro_escrita}
			Nessa situação, por algum motivo, um ponteiro que define um endereço de escrita fica nulo.
			Seja porque a memória alocada foi retornada em NULL e não foi verificada ou mesmo porque
			a aplicação não validou corretamente a entrada e o calculou indevidamente.
			O artigo de Mark Dowd, \cite{Dowd2008}, trata com riqueza de detalhes esse gênero de falha.
			

			Para que uma falha de NULL pointer desse tipo possa resultar em um ataque,
			podemos elencar dois pré-requisitos:
			\begin{itemize}
				\item{O ponteiro nulo é utilizado para calcular o endereço de uma escrita}
				\item{A escrita depende de algo fornecido pelo usuário além do NULL pointer}
				\item{Os dados a serem gravados podem ser controlados de alguma forma pelo usuário}
			\end{itemize}
			Abaixo, ilustrando o que foi exposto, um pequeno trecho de código em linguagem C.
			Nele, o usuário fornece dados, mas como o endereço base de destino de uma cópia está zerado,
			é possível influenciar diretamente na escolha de onde são gravados.
			Essa vulnerabilidade implica a condição do atacante de gravar em um endereço arbitrário dados
			que ele pode controlar - que pode ser um \textsl{shellcode}.
			\begin{lstlisting}[label=write_to_address,caption=Ponteiro em C]
/* user input at user_data */
write_address = null_pointer + offset_influenced_by_user;
/* the address has been 'chosen' by the user */

memcpy(write_address, user_data, certain_size);
/* data is copied from one point to another according to user's will */
			\end{lstlisting}
			
			
		\subsection{Ponteiro nulo de função}
			Ocorre quando, por necessidade de dinamismo, uma função que deve cumprir determinado
			papel, é definida por um ponteiro. Normalmente, ele deve conter um valor válido
			de um endereço de memória que contenha código que cumpra com as ações desejadas.
			Mas isso pode, na prática, não se confirmar. Um valor NULL pode estar no ponteiro
			no momento em que a função é chamada.

			
			Se o endereço zero não constituir uma região válida, a aplicação terminará com um erro.
			Mas e, se pusermos algo nessa região para ser executado? Imagine que um atacante tenha
			posto um \textsl{shellcode} justamente nesse ponto e provocou a chamada função definida pelo
			ponteiro nulo. Aí, certamente, poderíamos estar frente a um ataque com grandes chances de
			ser bem sucedido.
			

			Como pré-requisitos, podemos elencar, portanto:
			\begin{itemize}
				\item{Um ponteiro nulo define o endereço de uma função a ser chamada}
				\item{O usuário pode provocar a chamada dessa função}
				\item{É possível mapear para o endereço zero uma região válida de memória contendo dados do usuário}
			\end{itemize}
			Com esses pontos básicos atendidos, há condições para o emprego da técnica.
			Como exemplo maior, mostraremos um bug no Kernel do Linux na seção \ref{sec:exemplos_null_pointer}. 


	\section{Exemplos reais de NULL pointer exploit}
	\label{sec:exemplos_null_pointer}

		Nessa seção, apresentamos vulnerabilidades reais que exemplificam o exploit em estudo.
		Aquele que não poderia faltar, sem dúvida, é a falha tratada por Mark Dowd.
		Seu artigo é rico em detalhes e mostra todas as etapas que tornam possível
		um ataque.


		Também não poderíamos deixar de analisar os erros encontrados no Kernel do Linux em 2009.
		Isso porque problemas encontrados recentemente demonstraram que o sistema estava exposto
		fazia oito anos. "Eight Years of Linux Kernel Vulnerable": chegou a ser o título de matérias
		divulgadas na Internet como encontrado em \cite{Cunningham2009}.
		Não demorou muito para que uma caçada a NULL pointer fosse realizada para que diversas falhas
		fossem encontradas. Abordaremos duas delas.
			

		\subsection{Falha na máquina virtual do ActionScript}
			Trata-se de uma vulnerabilidade que se enquadra no que denominamos \textbf{ponteiro nulo de escrita} (em 
			\ref{subsec:ponteiro_escrita}).
			Consta no CVE como CVE-2007-0071. Foi objeto do estudo do artigo \cite{Dowd2008}.
			A falha ocorre na leitura de arquivos SWF(Shockwave Flash). Dados no arquivo são usados
			como parâmetros de alocação de memória. Se for passado um valor muito alto, como 2 gigabytes,
			a alocação não é bem sucedida e, por consequência, um ponteiro nulo é retornado.
			A aplicação realiza uma escrita na memória usando como parâmetros do cálculo do endereço de destino
			o ponteiro nulo com outro valor lido do arquivo (escolhido pelo usuário).
			Na página 7 de \cite{Dowd2008}, temos uma versão alto nível desse trecho de código
			em que ocorre o cálculo do endereço de destino e a escrita na memória.


			O destino da escrita é escolhido pelo usuário quase de forma arbitrária. Existem algumas restrições
			como divisibilidade por 12 quando somado a 4. Mas isso não impede que um ataque seja realizado.
			Como é possível acompanhar em \cite{Dowd2008}, criando um arquivo do tipo SWF da forma
			correta e manipulando detalhes da máquina virtual do ActionScript, o atacante torna-se
			capaz de executar seu \textsl{shellcode} na máquina alvo. Isso é feito através da construção
			de \textsl{bytecode} nativo para a máquina virtual ActionScript que permite a injeção do \textsl{shellcode}.
			Após a execução do último, a aplicação retorna normalmente ao seu fluxo criando a impressão que
			nada demais ocorreu.

			
			Pela enorme base de usuários que utilizam o Flash Player afetado, podemos dizer
			que o impacto da exploração dessa vulnerabilidade foi enorme.
			Principalmente porque a esmagadora maioria dos usuários jamais consideraria um
			uma apresentação em Flash como um potencial vetor de ataque.

			
			Vários fatores foram necessários para que um exploit fosse possível nesse caso.
			Falhas na validação de dados fornecidos pelo usuário foram os mais graves.
			Mas não foram os únicos. A aplicação também não soube lidar corretamente com erros
			na alocação de memória. Essa vulnerabilidade, como tantas outras, portanto, surge
			apenas pela combinação de uma série de problemas que são devidamente concatenados
			por uma mente criativa e obstinada de um atacante.
						
		
		\subsection{Falhas no kernel do Linux}
		\label{subsec:linux_kernel_vuln}
			Existem diversas falhas documentadas no kernel do Linux relacionadas a NULL pointer.
			Desde problemas na inicialização de estruturas de dados, condições de corrida
			inesperadas e até erros na compilação.		
			São falhas que surpreenderam pelo tempo que permaneceram escondidas e algumas até pela
			relativa facilidade de exploração conforme veremos a seguir.
	
			Iniciaremos pelo erro conhecido no CVE como CVE-2009-2692.
			Trata-se de uma vulnerabilidade muito grave que possibilita uma escalada de privilégios
			no sistema. Versões desde 2.6.0 a 2.6.30.4 e 2.4.4 a 2.4.37.4 estavam suscetíveis
			a esse \textsl{bug}; nada menos que 8 anos de \textsl{releases} do kernel.

			
			Sua origem encontra-se na inicialização incorreta de ponteiros de funções em estruturas
			de dados do kernel; nesse caso, \textsl{proto\_ops\_structures}. 
			Um \textsl{bug} em uma macro (SOCKOPS\_WRAP) acabava deixando não inicializadas
			funções responsáveis, por exemplo, de assumir o controle quando uma operação não disponível fosse
			requisitada. Enquadra-se, portanto, no que convencionamos como \textbf{ponteiro nulo de função}.

			
			Mais especificamente, quando um socket fosse usado e, fosse chamada a função sock\_sendpage,
			e não fosse possível enviar a página, a função sock\_no\_sendpage deveria ser despertada
			para tratar a situação. Mas, conforme explicamos, o valor NULL estaria ocupando o devido
			local do endereço da função sock\_no\_sendpage. Logo, o contexto da execução seria transferido
			para a região de memória iniciada em zero. Por isso, sendo injetado um código nesse bloco,
			ele seria executado com os privilégios do kernel. Em \cite{Tinnes2009}, é possível
			obter mais detalhes	sobre a questão.

	
			A seguir, segue o código que tira proveito dessa vulnerabilidade e possibilita ao atacante
			a execução de código com privilégio máximo no sistema.  
			\lstinputlisting[caption=Exploit para CVE-2009-2692]{exemplos_de_codigo_fonte/linux_cve_2009_2692.c}
			Na linha 14, é feito uma alocação de um bloco de memória iniciado no endereço zero; nele é posto
			o \textsl{shellcode}. Já a operação que desencadeia o erro encontra-se na linha 30.
			A chamada a sendfile irá exigir, no contexto criado de erro de envio, uma chamada 
			a sock\_no\_sendpage.
			Como o endereço dela estará em zero, conseguimos desviar para o \textsl{shellcode} no contexto do kernel.

			
			A segunda vulnerabilidade que utilizaremos como exemplo é conhecida no CVE como CVE-2009-3547.
			Qualquer versão anterior a 2.6.32-rc6 é vulnerável.
			Como o exemplo anterior, também trata-se de uma falha que possibilita escalada de privilégios.
			Mas é um \textsl{bug} de mais difícil compreensão e exploração. Ainda assim, vários \textsl{exploits}
			foram divulgados por diferentes autores; provando sua viabilidade.

			
			Ocorre devido a uma condição de corrida que pode deixar	um ponteiro nulo. De forma simplificada,
			podemos apontar a falha como uma não proteção de uma região crítica. As funções
			pipe\_read\_open(), bem como pipe\_write\_open() e pipe\_rdwr\_open(), relacionadas à intercomunicação
			de processos, podem não proteger corretamente o acesso ao ponteiro que controla o total de
			processos leitores/escritores. Podemos ver a dificuldade de reprodução dessa condição de corrida pelas
			palavras, \cite{git_kernel_org_cve2009_3547}, do desenvolvedor do kernel do Linux Earl Chew :
			"Note that the failure window is quite small and I could only
			reliably reproduce the defect by inserting a small delay".
			Segundo Earl, apenas uma pequena janela de tempo surgia para que o problema fosse detectado.
			
	
			Podemos considerar essa falha muito mais sutil em sua manifestação que a primeira.
			Ainda assim, pelo \textsl{diff} apresentado por Earl Chew para tratar o problema,
			vemos que, novamente, um caminho possível para evitar o pior foi a validação do ponteiro.
			Abaixo, apresentamos \textsl{patch} por Earl Chew, encontrado em \cite{git_kernel_org_cve2009_3547}, 
			que impede a exploração do erro.
			\lstinputlisting[caption=Patch para CVE-2009-3547]{exemplos_de_codigo_fonte/earl_chew_fix_cve2009_3547.patch}
			Vemos que nas linhas 14 a 19 temos a inserção de uma verificação do ponteiro i\_pipe.
			Logo, mesmo na presença da concorrência, não há chance de que i\_pipe seja deferenciado com valor NULL.
			
			
			Ambas as vulnerabilidades analisadas, ao nosso ver, apontam dois problemas graves.
			Primeiramente, a aparente falta de rigor nos testes. Como foi possível
			que uma vulnerabilidade como CVE-2009-2692 tenha permanecido por 8 anos sem ser descoberta
			pelos desenvolvedores? Como se trata de um problema de inicialização de variáveis,
			não seria tão complexo detectá-lo.
			
			
			Já a segunda questão que gostaríamos de apontar, é o problema do mapeamento do endereço
			zero por parte da aplicação do usuário permitindo que o kernel o acesse e execute
			código nele. Na seção \ref{subsec:memoria_virtual_linux_x86}, foi demonstrado como
			kernel e aplicações em modo usuário compartilham o mesmo espaço de endereçamento lógico.
			Essa decisão tem impacto direto sobre a possibilidade dos \textsl{exploits} abordados.
			Houvesse uma devida separação entre os segmentos, usando
			os atributos de base e limite por exemplo, isso jamais ocorreria. Pois o mapeamento
			do endereço zero em modo usuário não seria acessível pelo kernel.
			

			Como forma de tratar esse problema, foi usado o parâmetro mmap\_min\_addr.
			Ele define no sistema qual o endereço mais baixo que pode ser requisitado mapeamento
			de memória via mmap. Quando seu valor é diferente de zero, como 4Kb ou 64Kb,
			o mapeamento para endereço zero, até o valor escolhido, fica vedado.
			Por padrão, seu valor era zero, mas foi elevado para 4096 a partir de junho de 2009,
			como resposta às vulnerabilidades de NULL pointer.
			O autor do \textsl{patch} foi Christoph Lameter - encontrado em \cite{Lameter2009}
			
			
		\subsection{NULL pointer em ARM e XScale}
		\label{subsec:null_pointer_arm_xscale}
			Embora o foco do presente trabalho recaia sobre a arquitetura x86, é válido 
			identificar a repercussão de um acesso a posição zero de memória em outros casos.
			Existem arquiteturas nas quais esse endereço já é mapeado inicialmente. 
			Podemos apontar o caso da ARM e da XScale; ambas para sistemas embarcados. 
			Nelas, o vetor de exceções se encontra nessa posição. Ele contém, por exemplo,
			o endereço que define o vetor para o tratamento das interrupções de software.


			Essa vulnerabilidade, é tratada por Barnaby Jack, pesquisador de segurança da Juniper,
			em \cite{Jack2007}. Conforme Jack, caso alguma aplicação nas arquiteturas em questão
			possua alguma falha na qual o endereço de destino de uma escrita seja um ponteiro nulo,
			o vetor de exceções acaba sendo sobrescrito. Isso potencializa enormemente um erro
			de NULL pointer.


			Como exemplo, em \cite{Jack2007}, é apresentada uma falha na biblioteca libpng.
			Um tratamento inadequado da alocação de memória para imagens, que
			retornava NULL, permitia que os dados de uma imagem fossem copiados
			via memcpy() para o endereço zero. Por esse caminho, um atacante seria capaz
			de sobrescrever a tabela de endereços de interrupções de software.
			Assim, bastaria uma chamada do sistema em virtude de uma interrupção,
			para que o código injetado pudesse ser executado.

			
			Segundo avaliação de Jack, uma das formas de prevenir esse tipo de ataque é
			não permitir a escrita na área do vetor de exceções. Outra medida sugerida,
			e existente em versões posteriores das arquiteturas, como ARM9, é a possibilidade
			de mapeamento do vetor de exceções para endereços mais altos - como 0xFFFF00000.
			De qualquer forma, não resta dúvida que os projetistas cometeram sério
			equívoco nas escolhas envolvidas no vetor de exceções.
				
						

	\section{Como evitar o problema}
		Há vários caminhos que podem convergir para que não existam vulnerabilidades causadas 
		por ponteiros nulos. Nas seções anteriores, foram abordados diversos aspectos que
		demonstraram porque o problema existe e os pré-requisitos para que ele seja explorado.
		

		Podemos elencar três pontos principais sobre os quais podem se assentar as defesas
		e medidas de precaução contra os exploits de NULL pointer.
		A prevenção passa diretamente por:
		\begin{itemize}
			\item{Boas escolhas arquiteturais}
			\item{Um desenvolvimento consciente da ameaça do ponteiro nulo}
			\item{A aplicação contínua de testes}
		\end{itemize}
	
		\section{Decisões estruturais}		
			A forma como o sistema é concebido em termos de endereçamento e possibilidades de mapeamento
			das regiões de memória deve estar ciente do riscos impostos por ponteiros nulos.
			Conforme tratado na seção referente a exemplos de exploits, vide \ref{subsec:linux_kernel_vuln},
			não é aceitável que o sistema operacional divida com a aplicação do usuário o mesmo espaço
			de endereçamento. Considerando que

			
			Da mesma forma, de acordo com o exposto na seção \ref{subsec:null_pointer_arm_xscale}, 
			qualquer decisão arquitetural que coloque importantes estruturas de controle do sistema no 
			endereço zero, é extremamente temerária.
			Isso porque havendo uma referência a um ponteiro nulo que possa ser explorada, o atacante
			tem seu trabalho facilitado uma vez que haja um alvo direto na região de memória zero.
			Arquiteturas como a XScale, que deixam a tabela de rotina de interrupções iniciando no endereço zero,
			assumem um risco desnecessário.


			Assim, desde a concepção de uma arquitetura ou da organização de um sistema operacional,
			existem fatores que devem ser relevados sobre a ótica de uma vulnerabilidade de ponteiro nulo.
			Um design preventivo contribui decisivamente para que esse tipo de problema sequer seja possível.
			Mesmo que isso resulte em problemas de compatibilidade ou perdas de desempenho, as escolhas
			mais seguras devem ter prioridade.

		\section{Programação consciente}
			Como em todas as vulnerabilidades, o papel do programador é primordial.
			Sua incapacidade de vislumbrar situações de risco e tratá-las devidamente faz total diferença.
			É absolutamente necessário que essa forma de falha de segurança seja considerada.
			Um cuidado especial deve ser tomado para que não surjam ponteiros nulos
			durante a execução de uma aplicação e, mesmo que isso ocorra, que seja devidamente
			detectado e tratado.


			Certos procedimentos, portanto, são indispensáveis. Como, por exemplo, verificar se,
			ao alocar memória dinâmica, não recebemos um NULL. Não é aceitável que
			os ponteiros sejam manipulados sem a devida verificação. O programador não pode simplesmente
			assumir que receberá um endereço válido. Ambos os exploits reais apresentados, vide
			\ref{sec:exemplos_null_pointer}, poderiam ter sido evitados caso houvesse uma conferência correta
			dos valores manipulados.

			
			Logo, o conhecimento dos riscos que a falha de NULL pointer apresenta é essencial
			para que os desenvolvedores construam aplicações mais seguras.
			Padrões para validar ponteiros antes de seu uso devem ser apresentados e cobrados.
			Nesse aspecto, ferramentas automáticas para verificação da qualidade do código podem
			ser um grande diferencial. Assim, práticas de programação não seguras são
			detectadas desde a origem. TODO: referenciar parte de análise estática.

		\section{Testes}
			Toda e qualquer forma de teste contribui direta ou indiretamente para a detecção
			desse tipo de falha. Mas é essencial que a aplicação seja examinada sob
			a ótica de testes de requisitos negativos.
			No capítulo \ref{chap:fuzzing}, que trata de Fuzzing, são apresentadas
			diversas formas de testes que podem auxiliar.

			
			É possível, por exemplo, testar a aplicação simulando falhas na alocação de memória.
			De tal forma que, certas requisições de memória propositalmente retornem NULL.
			Com esse tipo de cenário, situações inusitadas podem ser criadas com facilidade.
			Analogamente, outras bibliotecas também podem ser substituídas por versões
			de teste que gerem contextos nos quais a aplicação é forçada a tratar ponteiros nulos.			


			No caso da vulnerabilidade CVE-2009-2692, analisada em \ref{subsec:linux_kernel_vuln},
			situações que simulassem uma falha no envio de um arquivo, como no 
			\textsl{exploit} apresentado para CVE-2009-2692, seriam suficientes para detectar o problema. 
			Isto porque ocorreria a falha na chamada a função cujo ponteiro estaria nulo.
			Por isso a enorme necessidade de testes, notoriamente aqueles que criem
			contextos em que falhas sejam inseridas.


