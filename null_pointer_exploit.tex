
\chapter{NULL pointer Exploit}
\label{chap:null_pointer_exploit}

	Dentre as várias técnicas de exploits existentes, uma que certamente merece
	destaque, é o NULL pointer exploit.
	Surgiu recentemente e é fruto da crescente dificuldade em aplicar técnicas
	que exploram vulnerabilidades de corrupção de memória.
	Em princípio, deferenciar um ponteiro nulo não é considerada
	uma vulnerabilidade explorável, mas, como veremos, isso nem sempre é verdade.

	
	Um marco para esse tipo de exploit certamente foi o artigo de Mark Dowd \cite{Dowd2008}.
	A forma como ele trouxe à luz uma falha na máquina virtual do ActionScript chamou
	a atenção de diversos especialistas na área. Ele enxergou e explicitou uma forma
	de explorar falhas antes consideradas meros causadores de crashes nas aplicações.
	O raciocínio empregado serviria de base para encontrar muitos outros problemas.

	
	O ano de 2009 chegou a ser considerado o ano do "kernel NULL pointer deference"
	em virtude da grande quantidade de falhas desse gênero encontradas no kernel do Linux.
	(citar http://cwe.mitre.org/top25/ para o ano de 2009)
	Vemos então que essa falha chegou a atingir notoriedade pelo grande impacto que causou.

	
	Nessa capítulo, nossa intenção é apresentar esse tipo de exploit, mostrar como 
	pode ocorrer, ilustrando com exemplos e apontando formas de prevenção.
	Muito embora existam várias formas de 
	
	
	\section{O que é um NULL pointer}
		O primeiro ponto a ser abordado é o NULL pointer.
		Na linguagem de programação C, podemos considerar um ponteiro como um valor inteiro
		que referencia uma posição de memória. Ou seja, trata-se de um valor que aponta
		para o início de uma determinada região de memória. Quando um ponteiro é deferenciado,
		passamos a acessar o valor presente na posição de memória para o qual ele aponta.
		Ilustrando, segue pequeno trecho de código C.
		\begin{lstlisting}[label=pointer_example,caption=Ponteiro em C]
int val = 10;
int *pointer = &value;
/* pointer possui o endereco de val */
/* *pointer retorna 10 */
		\end{lstlisting}
		

		No Linux, o arquivo stddef.h contém a definição de NULL, que por
		convenção, denomina um ponteiro com valor zero.
		Um ponteiro nulo, então, aponta para a posição zero de memória. 
		Como, em regra geral, os sistemas utilizam o esquema de memóra virtual,
		na prática, esse endereço zero deve ser considerado tão somente no espaço
		de endereçamento do processo em questão.
		Como normalmente ele não constitui um mapeamento válido, pois os processos não
		iniciam com aquela porção mapeada, os acessos a essa região implicam violação
		às regras do esquema de memória virtual. Erros como esse resultam
		no término da aplicação. Por isso, na maioria dos casos, um acesso a um ponteiro
		nulo é apenas sinônimo de uma DoS (negação de serviço).


		Embora o foco do trabalho recaia sobre a arquitetura x86, é válido identificar a repercussão
		de uma acesso a posição zero de memória em outros casos.
		Existem arquiteturas nas quais o endereço zero já é mapeado inicialmente. 
		Podemos apontar o caso da ARM e da XScale; ambas para sistemas embarcados. 
		Nelas, o vetor de exceções se encontra nessa posição. Ele contém
		endereços para o tratamento de, por exemplo, interrupções de hardware e software.
		Naturalmente, um acesso a um ponteiro nulo nesses casos constitui enorme
		problema em termos de segurança. Alterando a posição do vetor referente ao tratamento
		de uma interrupção corriqueira como \textsl{pagefault}(disparada quando uma página
		virtual não possui sua correspondente na memória física), seria possível desviar o fluxo
		de execução do processo para código malicioso injetado pelo atacante.

		
		Diversas falhas em uma aplicação real podem levar à presença de um ponteiro zerado.
		Falhas ao inicializar uma estrutura de dados pode deixar ponteiros nulos inadvertidamente.
		Outro possível problema pode ocorrer quando o sistema tem sua memória esgotada e, 
		a chamada responsável por alocar mais espaço retorna NULL, mas como essa possibilidade não é considerada
		pelo programador, o ponteiro a receber esse bloco de memória acaba ficando zerado e a aplicação
		segue normalmente.
		
		Vemos, portanto, que um ponteiro nulo é um caso particular no qual a região de memória
		referenciada é aquela que inicia no endereço zero (no contexto de endereçamento do
		processo em questão - considerado o uso de memória virtual). 
		Exceto em casos especiais, essa situação leva a erros na aplicação que resultam em seu término.
		Conforme trataremos a seguir, há casos em que um ponteiro nulo irá possibilitar um ataque.		

	\section{Como funciona a técnica}
		A técnica de exploração desse tipo de vulnerabilidade irá variar conforme o contexto
		em que surge e como é utilizado o ponteiro nulo. 
		Conforme exposto anteriormente, esse método não é tão genérico como as falhas de \textsl{buffer overflow}.
		São ataques mais focados que exigem ajustes muito maiores em função das especifidades da aplicação alvo.
		Como em outros gêneros de exploits, o objetivo desejado é a escrita de dados fornecidos 
		pelo usuário em endereços arbitrários. Pois isso possibilita, por exemplo,
		a cópia de um \textsl{shellcode} para ser executado. Mas isso não é uma regra, há falhas
		de NULL pointer que envolvem ponteiros para funções que possuem um caminho mais simples
		para exploração.

	
		Para fins de simplificação, vamos dividir os tipos de ataques com essa técnica em duas famílias.
		Como podem existir várias formas de exploração de aplicações em que surgem ponteiros nulos,
		para facilitar a compreensão, vamos tomar dois tipos representativos que são capazes de passar
		a ideia fundamental.
		Numa delas, um endereço que define a localização de uma escrita depende de um ponteiro zerado.
		Em outra, esse ponteiro define uma função a ser executada.
		A primeira chamaremos de \textbf{ponteiro nulo de escrita} e a segunda de \textbf{ponteiro nulo de função}.


		\subsection{Ponteiro nulo de escrita}
		\label{subsec:ponteiro_escrita}
			Nessa situação, por algum motivo, um ponteiro que define um endereço de escrita fica nulo.
			Seja porque a memória alocada foi retornada em NULL e não foi verificada ou mesmo porque
			a aplicação não validou corretamente a entrada e o calculou indevidamente.
			O artigo de Mark Dowd, \cite{Dowd2008}, trata com riqueza de detalhes esse gênero de falha.
			

			Para que uma falha de NULL pointer desse tipo possa resultar em um ataque,
			podemos elencar dois pré-requisitos:
			\begin{itemize}
				\item{O ponteiro nulo é utilizado para calcular o endereço de uma escrita}
				\item{A escrita depende de algo fornecido pelo usuário além do NULL pointer}
				\item{Os dados a serem gravados podem ser controlados de alguma forma pelo usuário}
			\end{itemize}
			Abaixo, ilustrando o que foi exposto, um pequeno trecho de código em linguagem C.
			Nele, o usuário fornece dados, mas como o endereço base de destino de uma cópia está zerado,
			é possível influenciar diretamente na escolha de onde são gravados.
			Essa vulnerabilidade implica a condição do atacante de gravar em um endereço arbitrário dados
			que ele pode controlar - que pode ser um \textsl{shellcode}.
			\begin{lstlisting}[label=write_to_address,caption=Ponteiro em C]
/* user input at user_data */
write_address = null_pointer + offset_influenced_by_user;
/* the address has been 'chosen' by the user */
memcpy(write_address, user_data, certain_size);
/* data is copied from one point to another according to user's will */
			\end{lstlisting}
			
			
		\subsection{Ponteiro nulo de função}
			Ocorre quando, por necessidade de dinamismo, uma função que deve cumprir determinado
			papel, é definida por um ponteiro. Normalmente, ele deve conter um valor válido
			de um endereço de memória que contenha código que cumpra com as ações desejadas.
			Mas isso pode, na prática, não se confirmar. Um valor NULL pode estar no ponteiro
			no momento em que a função é chamada.

			
			Se o endereço zero não constituir uma região válida, a aplicação terminará com um erro.
			Mas e, se pusermos algo nessa região para ser executado? Imagine que um atacante tenha
			posto um \textsl{shellcode} justamente nesse ponto e provocou a chamada função definida pelo
			ponteiro nulo. Aí, certamente, poderíamos estar frente a um ataque com grandes chances de
			ser bem sucedido.
			

			Como pré-requisitos, podemos elencar, portanto:
			\begin{itemize}
				\item{Um ponteiro nulo define o endereço de uma função a ser chamada}
				\item{O usuário pode provocar a chamada dessa função}
				\item{É possível mapear para o endereço zero uma região válida de memória contendo dados do usuário}
			\end{itemize}
			Com esses pontos básicos atendidos, há condições para o emprego da técnica.
			Como exemplo maior, mostraremos um bug no Kernel do Linux na seção \ref{sec:exemplos_null_pointer}. 


	\section{Exemplos reais de NULL pointer exploit}
	\label{sec:exemplos_null_pointer}

		Nessa seção, apresentamos vulnerabilidades reais que exemplificam o exploit em estudo.
		Aquele que não poderia faltar, sem dúvida, é a falha tratada por Mark Dowd pelo fato
		ter servido de inspiração


		Também não poderíamos deixar de analisar os erros encontrados no Kernel do Linux em 2009.
		Isso porque 
			

		\subsection{Falha na máquina virtual do ActionScript}
			Trata-se de uma vulnerabilidade que se enquadra no que denominamos \textbf{ponteiro nulo de escrita} (em 
			\ref{subsec:ponteiro_escrita}).
			Consta no CVE como CVE-2007-0071. Foi objeto do estudo do artigo \cite{Dowd2008}.
			A falha ocorre na leitura de arquivos SWF(Shockwave Flash). Dados no arquivo são usados
			como parâmetros de alocação de memória. Se for passado um valor muito alto, como 2 gigabytes,
			a alocação não é bem sucedida e, por consequência, um ponteiro nulo é retornado.
			A aplicação realiza uma escrita na memória usando como parâmetros do cálculo do endereço de destino
			o ponteiro nulo com outro valor lido do arquivo (escolhido pelo usuário).
			Na página 7 de \cite{Dowd2008}, temos uma versão alto nível desse trecho de código
			em que ocorre o cálculo do endereço de destino e a escrita na memória.
			

			TODO: registrar versões vulneráveis.
			

			O destino da escrita é escolhido pelo usuário quase de forma arbitrária. Existem algumas restrições
			como divisibilidade por 12 quando somado a 4. Mas isso não impede que um ataque seja realizado.
			Como é possível acompanhar em \cite{Dowd2008}, criando um arquivo do tipo SWF da forma
			correta e manipulando detalhes da máquina virtual do ActionScript, o atacante torna-se
			capaz de executar seu \textsl{shellcode} na máquina alvo. Isso é feito através da construção
			de \textsl{bytecode} nativo para a máquina virtual ActionScript que permite a injeção do \textsl{shellcode}.
			Após a execução do último, a aplicação retorna normalmente ao seu fluxo criando a impressão que
			nada demais ocorreu.

			
			Pela enorme base de usuários que utilizam o Flash Player afetado, podemos dizer
			que o impacto da exploração dessa vulnerabilidade foi enorme.
			Principalmente porque a esmagadora maioria dos usuários jamais consideraria um
			uma apresentação em Flash como um potencial vetor de ataque.

			
			Vários fatores foram necessários para que um exploit fosse possível nesse caso.
			Falhas na validação de dados fornecidos pelo usuário foram os mais graves.
			Mas não foram os únicos. A aplicação também não soube lidar corretamente com erros
			na alocação de memória. Essa vulnerabilidade, como tantas outras, portanto, surge
			apenas pela combinação de uma série de problemas que são devidamente concatenados
			por uma mente criativa e obstinada de um atacante.
						
		
		\subsection{Falhas no kernel do Linux}
			Existem diversas falhas no kernel do Linux relacionadas a NULL pointer.
			Desde problemas na inicialização de estruturas de dados até a erros na compilação.		
			Para exemplificar, trataremos de um erro conhecido no CVE como CVE-2009-2692.
			Trata-se de uma vulnerabilidade muito grave que possibilita uma escalada de privilégios
			no sistema.
			
			
			A origem do problema encontra-se na inicialização incorreta de ponteiros de funções em estruturas
			de dados do Kernel (como \textsl{proto\_ops\_structures}). 
			Um \textsl{bug} em uma macro (SOCKOPS\_WRAP) acabava deixando não inicializado
			funções responsáveis, por exemplo, de assumir o controle quando uma operação não disponível fosse
			requisitada. Enquadra-se, portanto, no que convencionamos como \textbf{ponteiro nulo de função}.

			
			Mais especificamente, quando um socket fosse usado e, fosse chamada a função sock\_sendpage,
			e não fosse possível enviar a página, a função sock\_no\_sendpage deveria ser despertada
			para tratar a situação. Mas, conforme explicamos, o valor NULL(zero) estaria ocupando o devido
			local do endereço da função sock\_no\_sendpage. Logo, o contexto da execução seria transferido
			para a região de memória iniciada em zero. Por isso, sendo injetado um código nesse bloco,
			ele seria executado com os privilégios do Kernel.
			TODO: citar http://blog.cr0.org/2009/08/linux-null-pointer-dereference-due-to.html.

	
			A seguir, segue o código que tira proveito dessa vulnerabilidade e possibilita ao atacante
			a execução de código com privilégio máximo no sistema.  
			\lstinputlisting{exemplos_de_codigo_fonte/linux_cve_2009_2692.c}

			
			Essa vulnerabilidade, que podemos considerar de alto impacto mas de simples exploração,
			na nossa avaliação, surge devido a duas falhas gravíssimas.
			A primeira, duramente criticada por especialistas, é o compartilhamento do espaço de endereçamento
			do Kernel do Linux com o processo do usuário. Essa decisão arquitetural
			tornou possível que uma simples chamada a mmap, no processo do usuário, tivesse o alcance de
			mapear a região de memória zero no contexto do Kernel. 
		

	\section{Proteções}
