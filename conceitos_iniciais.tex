
\chapter{Conceitos iniciais}
\label{chap:conceitos_iniciais}

	\section{Exploit/Vulnerabilidade}
	O primeiro termo que devemos definir neste trabalho é \textsl{exploit}. Mas antes dele,
	trataremos de vulnerabilidade - pois eles têm uma ligação estreita.
	Podemos definir vulnerabilidade como uma falha em um sistema que permite
	a um atacante usá-lo de uma forma não prevista pelo projetista \cite{Anley2007}.
	Ou seja, uma vulnerabilidade implica a possibilidade de uso indevido de um sistema.
	Os passos necessários para explorar essa fraqueza, ou mesmo o código (programa) que pode tirar
	proveito da vulnerabilidade é descrito como \textsl{exploit}.
	Um \textsl{exploit} surge apenas quando há uma vulnerabilidade - mas podem existir
	vulnerabilidades para as quais não exista \textsl{exploit}.


	\section{Conceitos básicos}
	Neste trabalho iremos tratar de \textsl{exploit}s na arquitetura x86 de 32 bits. Trata-se da arquitetura de computadores
	pessoais mais difundida nos dias de hoje. Mas boa parte do estudo realizado pode ser aplicada
	a praticamente qualquer outra arquitetura.

	\section{Gerência de memória}
	O controle da memória é um ponto crítico. Falhas nele acabam resultando em vulnerabilidades 
	gravíssimas. Faremos uma breve abordagem sobre o gerenciamento de memória sobre
	o ponto de vista dos \textsl{exploit}s.

	Um primeiro ponto a destacar sobre a memória é um princípio básico que norteia
	quase todas as arquiteturas modernas. Dados e instruções não são diferenciados na memória.
	Ou seja, não há uma separação rígida entre instruções que compõem um programa e os dados
	sobre os quais opera. Essa característica foi herdada da arquitetura básica de von Neumann.
	Como veremos a seguir, essa decisão de design, com origem nos anos 1940, embora tenha
	facilitado a evolução dos computadores, abriu caminhos para os \textsl{exploit}s que conhecemos hoje. 

	Abaixo descrevemos o layout básico da memória de um processo em um sistema UNIX.
	Ele pode ser separado em 6 partes fundamentais:
	\begin{description}
		\item[text]
			A parte que contém as instruções do programa - seu código propriamente dito.
			Seu tamanho é fixo durante a execução e ela não deve possibilitar escrita.
		\item[data]
			Contém variáveis globais já inicializadas. Seu tamanho é fixo durante a execução.
		\item[bss]
			Nome de origem história significando Block Started by Symbol. Área da memória responsável
			por armazenar variáveis globais	não inicializadas. Como text e data, bss também tem tamanho 
			fixo conhecido desde o início do processo. 
		\item[Heap]
			Espaço para variáveis alocadas dinamicamente. A chamada de sistema sbrk é responsável
			pelo controle do crescimento/encolhimento desse espaço. Bibliotecas geralmente facilitam a vida
			do programador disponibilizando interfaces mais amigáveis como malloc() e free(). Assim a biblioteca
			se encarrega de chamar sbrk() para diminuir/aumentar o Heap. Ela cresce do endereço mais baixo para o
			mais alto.
		\item[Stack]
			Mantém controle das chamadas de funções. Possibilita a recursividade. Logo, possui
			tamanho variável - crescendo do endereço mais alto para o mais baixo (sendo antagonista do Heap - ver
			figura \ref{fig:regioes_memoria}). 
			Esse crescimento é que torna possível que uma chamada de função que tenha seus dados
			sobrescritos influencie numa chamada de função anterior. Esse é o princípio do buffer overflow - tratado
			posteriormente.
		\item[Enviroment]
			A última porção de memória do processo guarda uma cópia das variáveis de ambiente do sistema.
			Essa seção possui permissão de escrita, mas como bss, data e text, possui tamanho fixo.
	\end{description}

	\begin{figure}
		\begin{center}
		\includegraphics[width=0.45\textwidth]{regioes_memoria.pdf}
		\caption{Regiões de memória em um processo.}
		\label{fig:regioes_memoria}
		\end{center}
	\end{figure}

	\section{Funcionamento mais detalhado do Stack}
	A pilha é uma região contínua com base fixa e tamanho variável.
	Na arquitetura abordada por esse trabalho, x86 (bem como em muitas outras), a pilha cresce
	em direção ao endereço mais baixo. É organizada em \textsl{frames} que são os blocos
	alocados quando ocorrem chamadas a funções. Cada \textsl{frame} contém(ver figura \ref{fig:stack_frame}):
	\begin{itemize}
		\item parâmetros
		\item variáveis locais
		\item endereço de retorno da função anterior
		\item endereço do \textsl{frame} da função que a chamou
	\end{itemize}

	\begin{figure}
		\begin{center}
		\includegraphics[width=0.5\textwidth]{stack_frame_furlan.jpg}
		\caption{Organização do \textsl{frame} na pilha. Retirado de \cite{Furlan2005} pg. 17.}
		\label{fig:stack_frame}
		\end{center}
	\end{figure}

	\subsection{Chamada de funções}
	Quando uma função é chamada, seus parâmetros são empilhadas e posteriormente o endereço
	do retorno. Isso fica a encargo da função que faz a chamada.
	Para completar o \textsl{frame}, aquela que é chamada, empilha o endereço do frame da função chamadora
	(EBP) e posteriormente aloca na pilha o espaço correspondente a suas variáveis locais.
	É importante ressaltar que, caso o endereço de retorno, empilhado por quem chama, seja alterado,
	o fluxo de execução é mudado. Pois é justamente este o princípio do \textsl{buffer overflow}.

	\section{Funcionamento mais detalhado do Heap}
	A porção de memória correspondente ao heap possibilita ao programador alocar dinamicamente memória
	que fica disponível durante toda a execução para qualquer chamada de função. Diferentemente
	da memória alocada no stack - que é perdida quando a função retorna.

	\section{Mapemamento de memória anônimo}
	Como visto no funcionamento básico do Heap, a fragmentação é um problema a ser considerado.
	Uma forma alternativa de alocar memória dinamicamente que não usa o Heap são os mapeamentos anônimos.
	No Linux por exemplo, através da função mmap() é possível alocar um bloco de memória contínuo
	fora do Heap que não está sujeito aos problemas de fragmentação.
	Conforme, \cite{Love2007}, é possível considerar esse espaço de memória como um novo Heap
	vindo de apenas uma alocação.
	No exemplo a seguir, é requisitado uma porção de memória de 64 bytes iniciando em NULL.
	\begin{verbatim}
		mmap(NULL, 64, PROT_READ | PROT_WRITE,
			MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
	\end{verbatim}
	Na técnica \textsl{NULL pointer exploit}, conforme veremos mais adiante, essa possibilidade
	de alocarmos um bloco com o início pré-determinado é muito útil.
	No caso da chamada de mmap() do exemplo anterior, estamos obtendo um bloco de 64 bytes começando
	no endereço zero(NULL). Isso nos permite colocar código executável nessa porção da memória e,
	na presença de uma vulnerabilidade, desviar a execução para esse ponto.
	
	\section{Registradores de controle}
	Uma parte fundamental da arquitetura que deve ser mencionada são os registradores que possuem
	relação direta com o gerenciamento da memória.
	Talvez o mais importante (na arquitetura base do estudo IA32) seja o EIP(Extended Instruction Pointer).
	Ele indica o endereço da próxima instrução. Sobrescrevê-lo equivale obter o controle
	do fluxo de um processo.
	Além dele, destacamos EBP(Extended Base Pointer) e ESP(Extended Stack Pointer).
	ESP indica o endereço do último valor inserido na pilha.
	O EBP indica o início da pilha para aquela chamada de função. É usado para referenciar variáveis
	locais da função.


